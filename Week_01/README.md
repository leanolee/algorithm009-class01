学习笔记

# 周总结-week01

## 本周目标

#### 数组、链表、跳表

1. 熟练掌握数组、链表的优劣，以及使用的场景

   > 数组：升维为2、3维；空间换时间
   >
   > 链表：演变为树

2. 在刷题时，能非常熟练的掌握数组、链表的选择、使用、技巧

3. 深入理解跳表原理，并涉及LRU Cache、Redis的学习、使用

#### 栈、队列、优先队列、双端队列

1. 熟练掌握Stack、Queue、Deque数据结构，以及应用

2. 学习掌握它们在Java等源码中的实现，并能自己实现

3. 对Priority Queue深入理解，为它的扩展做准备

4. 尤其是Stack、Queue、Deque三者，在刷题时的选择、使用、技巧，要非常敏感

   > Stack：洋葱型结构、最近相关性
   >
   > Queue：排队公平性（暂未遇到）
   >
   > Deque：滑动窗口，sliding window

## 学习方法

#### 视频

1. 学习第一遍时，只看。目标是，理解视频90%+的内容

   > 看完第一遍后，针对疑点、难点进行自我补充学习

2. 学习第二遍时，思路要紧跟，甚至提前想到下一步的思路

   > 仅针对重点、难点，进行回放学习

#### 资源

1. 扩充的知识点，要花时间去学习，不求精细，但求快准，如：

   > LRU缓存算法：https://www.jianshu.com/p/b1ab4a170c3c
   >
   > 跳跃表：http://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html
   >
   > 等等

2. 学习源码中数据结构的实现，如：

   > Priority Queue：http://developer.classpath.org/doc/java/util/PriorityQueue-source.html

3. 其他优秀文章，如：

   > 双指针技巧总结：https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/shuang-zhi-zhen-ji-qiao

## 刷题方法

#### 做题

1. 从简单开始。第一遍做题时，尽量先自己想一会自己思路，哪怕是最简单直观的思路。因为更高级的解法，往往是最暴力、简单的解法，一步步演变过来

   > 理解难题，从理解简单的方法，一步步演变到理解最难、最简介的方法

2. 不死磕。尤其是第一遍做题时，第一次遇到这种题型，很多以前没有踩过的坑，没有遇到、学习到的经验，不是随便能摸索到的。这时候学习leetcode上官方的多种解题思路，和别人的优秀的解题技巧和经验，就非常重要

   > 切记！切记！不死磕！先学习优秀的解法，再尝试变成自己的思路和解法

3. 画图&笔记。

   1. 晦涩难懂的思路和题解，有时很难一下理解和学习到，不仅要多动脑去想，更要多动手去画

      > 比如所有链表的题，涉及到节点的交换，画画图非常帮助理解
      >
      > 比如stack、deque、接雨水的题目，画图能帮助自己更快、更好的理解和掌握

   2. 然后将自己能理解的思路、题解记成笔记，因为当下的理解并不代表长期的理解，笔记可以帮助自己规避遗忘周期和再学习的成本

      > 做笔记是对已学知识的巩固，也是复习和输出、总结

#### 刷题

1. 刷题之前，回顾该题已掌握的各种方法
2. 挑选2-3种方法，快速编码，如果遇到有很细节的地方没有把握到，或者提交不成功，也不要死磕
3. 针对刷题时遇到的问题，再进行方法上的总结思考
4. 再学习leetcode-cn、leetcode.com上优秀的题解：细节、技巧
5. 尝试思考总结类似题目的差别和共同点

#### 其他

##### leetcode-15：三数之和

1. 难点：去重

2. 关键：先排序

3. 思路总结：

   ```go
   暴力法：O(n^3),O(1):O(s*3)s为答案的数量，不是额外的空间，不计入
   	1.一层循环：固定第一个数，如果nums[i] >0，则后面的结果都可以放弃了，直接返回
   		如果 当前数index >0 && 当前数 == 上一个数，continue
   	2.二层循环：固定第二个数
   		如果 当前索引和第一个数索引没紧挨着 && 当前数 == 上一个数，continue
   	3.三层循环：寻找第三个数
   		如果 当前索引和第一个数索引没紧挨着 && 当前数 == 上一个数，continue
   两数之和+memo演进：O(n^2),O(n)+O(n^2)
      1.遍历数组，将 sum = 0 - nums[i]，存入数组 sums 中，3数之和变成求解：2数之和，寻找 num2+num3=-num1
      2.一层循环：固定 sums 中的数（也就是每个 2数之和）
         如果 memo[i]<0，说明对应的 num1 > 0，则放弃寻找，直接结束函数
         去重一：如果 当前数index >0 && 当前数 == 上一个数，continue
      3.二层循环：每开始一次这层循环，都要创建一个新的 memo，按照 2数之和 的算法，寻找结果 num2、num3
         去重二：避免回头再遍历一层已经遍历过的情况，j 从 i+1 开始遍历
         去重三：-num1 == 2 * num2 的情况，如果两个索引间值 j-i >1 && 当前值nums[j]==nums[j-1]
            1.nums[j]*2 = 2数之和，且 j-i==2，该情况成立
            2.别的情况，继续遍历
            if j-i > 1 && nums[j] == nums[j-1] {
               if nums[j]<<1 == sums[i] && j-i == 2 {
                  threeSums = append(threeSums, []int{nums[i], nums[j-1], nums[j]})
               }
               continue
            }
   双指针：O(n^2),O(1)
      1.一层循环：固定num1，若nums[i] >0，结束函数
         去重一：index >0 && nums[index] == nums[index-1]，continue
      2.二层循环：双指针 start、end，分别从头、尾，推进直到相遇
         计算 sum > 0; end--
            sum < 0; start++
         去重二：如果 nums[start]==nums[start-1] && start<end; start++
            end同理
   ```

##### leetcode-84&42：柱状图中最大的矩形、接雨水

1. 难点：左右边界的理解

2. 关键：Stack出入栈及索引算法

3. 思路总结：以接雨水为例

   ```go
   暴力法：O(n^2),O(1)
      思路：每一个元素，找它左、右最高的元素
      1.一层循环：固定当前元素
      2.二层循环：分别往左、右找最高元素，再取两者较小值，min
         若 min > height[current]
         sum += min - height[current]
   dp：O(n),O(n)
      思路：灵感来自于 leetcode-239
      1.创建两个数组，分别记录：左->右，右->左
         递推的 height[left]、height[right] 两者的最大值 分别与 height[current] 的差值
      2.一次循环：完成上一步
      3.取两个数组中较小的值，累加
   Stack：O(n),O(n)
      思路：具有最近相关性，可用栈来解决
      1.创建stack
         新元素若比栈顶元素小，直接入栈
         若比栈顶元素大，则依次弹出，计算
      2.一次循环：(min(stack[top-1], height[i]) - stack[top]) * (i - Idx(top-1) - 1)
         将结果累加
   双指针：O(n),O(1)
      思路：来自dp，dp方法中两个数组的数据规律：最大元素的左侧 都小于 最大元素的右侧；反之亦然
      1.左右变量 left right 分别记录，左右递推的最大元素
      2.一次循环：哪边值更小，则哪边往中间推进
         左右分别计算，如：
            height[i] < left，累加差值
            height[i] > left，left = height[i]
   ```

