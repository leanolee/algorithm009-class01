#### 5-最长回文子串

1. 审题过程：根据题意，推进思路

   > 由给出的示例可猜：s = "cbbd"

   1. 暴力法：O($n^3$)第一层循环固定首字符，第二层循环固定尾字符，第三层循环遍历 首尾 之间的子串是否是回文串

      ```go
      for i := 0; i < n; i++ {
          for j := 0; j < n; j++ {
              for l, r := i, j; l < r; l, r = l+1, r-1 {
                  if s[l] != s[r] {
                      // 不是回文子串
                  }
              }
          }
      }
      ```

   2. 根据暴力法，可以发现第二三层循环存在冗余的计算：因为我们已经在第二层循环遍历过 i ~ j 之间的字符了，所以有两种优化的可选思路

      1. 可以想到一种 O($n^2$) 的算法：中心扩展算法（略）
      2. 递推思想：在计算 i ~ j 之间的子串是否为回文串时，可以先看 i+1 ~ j-1 之间的子串是否为回文串

   3. 根据上面的递推思想，可以细化为：

      > 使用二维矩阵，i j 记录子串的起始位置，分三种情况：
      >
      > 1. 当 i==j 时，说明两个指针指向同一个位置，一个字符的子串肯定是回文串
      >
      > 2. s[i] != s[j]，不是回文串
      >
      > 3. s[i] == s[j]，查询已记录的 i+1 ~ j-1 之间的子串是否为回文串，如果是，则 i ~ j 也是
      >
      >    > 可以发现有一种特殊情况：当 i+1==j 时，i+1 ~ j-1 实质又变回了 i ~ j，所以此时不用附加额外的判断

2. 根据推进的同时，画图表支持：由于思路比较简单，且已经很清晰，所以略

   > 注意：通过图表，可以发现该矩阵为对称矩阵，只用遍历一半 + 斜线

3. 状态定义

   1. 由上述分析，我们可以写出状态定义bool矩阵 dp[i] [j]
   2. i：子串起始位置，j：子串终止位置，dp[i] [j]：i ~ j 的子串

4. 状态转移方程

   1. i == j，dp[i] [j] = true

   2. s[i] != s[j]，dp[i] [j] = false

   3. s[i] == s[j]：

      > i+1==j：dp[i] [j] = true
      >
      > 否则：dp[i] [j] = dp[i+1] [j-1]

   4. 记录 max，l 分别表示最长子串，和最长子串的起始位置，根据 dp[i] [j] 的状态，更新 max 和 l 的值

5. 复杂度分析：

   1. 时间复杂度：O($n^2$)
   2. 空间复杂度：O($n^2$)

6. Code

   ```go
   /*
   dp：个人写法
   解释：换个方式，初始化 dp 矩阵记录当前回文串的长度
   	1.边界条件
   	2.记录max，l
   		2.1.更新max，l
   		2.3.根据max，l计算返回值
   	3.递推
   		3.1.i==j
   			dp[i][j] = 1
   		3.2.s[i] != s[j]
   			dp[i][j] = 0
   		3.3.s[i] == s[j] && dp[i+1][j-1] > 0
   			dp[i][j] = dp[i+1][j-1] + 2
   			即 s[i~j] 是回文串
   		3.4.s[i] == s[j] && i+1==j
   			dp[i][j] = 2
   */
   func longestPalindrome(s string) string {
       n := len(s)
   	if n < 2 {	// 1
   		return s
   	}
   	dp, max, l := make([][]int, n), 1, 0	// 2
   	for i := 0; i < n; i++ {	// 3
   		dp[i] = make([]int, n)
   		dp[i][i] = 1	// 3.1
   		for j := 0; j < i; j++ {
   			if s[i] != s[j] {	// 3.2
   				continue
   			}
   			if i-j == 1 {	// 3.4
   				dp[j][i] = 2
   			} else if dp[j+1][i-1] > 0 {	// 3.3
   				dp[j][i] = dp[j+1][i-1] + 2
   			}
   			if dp[j][i] > max {	// 2.1
   				max, l = dp[j][i], j
   			}
   		}
   	}
   	return s[l : l+max]	// 2.2
   }
   ```

