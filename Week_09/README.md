学习笔记

## 周总结-week08

> 记录自己首次完全独自解决困难DP

#### 115-不同的子序列

1. 审题过程：根据题意，推进思路

   > 由给出的示例可猜：S = "babgbag", T = "bag"

   1. 当最后一个字符 g 出现时：

      > bag出现的次数 = b的次数 * a的次数 * g的次数

   2. 但由于字符出现的顺序是随意的，所以调整为，当g出现时：

      > bag出现的次数 = 之前 bag 出现的次数 + sum(每个连续 a 出现的区间中 a 的次数 * 每个 a 之前出现 b 的次数）

   3. 把 ba 也纳入递推中，可得当 g 出现时：

      > bag出现的次数 = 之前 bag 出现的次数 + 之前 ba 出现的次数

2. 根据推进的同时，画图表支持：S = "babgbag", T = "bag"

   > 表格中第6行第3列：[3, 1]代表的是：babgb中出现ba的情况，3：b出现3次，1：ba出现1次
   >
   > 同理，最后一行最后一列：[3, 4, 5]代表：b出现3次，ba出现4次，bag出现5次

   |   S\T   |  b   |     a      |       g       |
   | :--: | :--: | :--------: | :-----------: |
   |  b   |  1   |   [1, 0]   |   [1, 0, 0]   |
   |  a   |  1   |   [1, 1]   |   [1, 1, 0]   |
   |  b   |  2   |   [2, 1]   |   [2, 1, 0]   |
   |  g   |  2   |   [2, 1]   |   [2, 1, 1]   |
   |  b   |  3   | **[3, 1]** |   [3, 1, 1]   |
   |  a   |  3   |   [3, 4]   |   [3, 4, 1]   |
   |  g   |  3   |   [3, 4]   | **[3, 4, 5]** |

3. 状态定义

   1. 由上述表格，我们可以写出状态定义 dp[i] [j] [j]
   2. i：行数，j：列数，j：T中的第几个字符

4. 状态转移方程

   1. 上述表格 + 递推猜想：bag出现的次数 = 之前 bag 出现的次数 + 之前 ba 出现的次数，可得：

      1. 第 i 行，第 j 列的数据，可以首先拷贝自 dp[i] [j-1]，以表格中**第7行第3列 [3, 4]** 为例：先拷贝**第7行第2列**，[3, 0]
      2. 新增列拷贝自：**第6行第2列**，[3, 1]
      3. 此时 S[5] == T[1]，则新增列要加上（左上角） **第7-1行第3-2列** 的 [3]，得 [3, 4]

   2. 考虑到上面表格中第2列（b）的计算（当b == b时，左上角没有 1 提供增量），对表格进行添加初始行和列，并将新增列都赋值为 1

      |   S\T   |  #   |   b   |     a      |     g     |
| :--: | :--: | :---: | :--------: | :-------: |
      |  #   |  1   |       |            |           |
      |  b   |  1   |   1   |   [1, 0]   | [1, 0, 0] |
      |  a   |  1   |   1   |   [1, 1]   | [1, 1, 0] |
      |  b   |  1   |   2   |   [2, 1]   | [2, 1, 0] |
      |  g   |  1   |   2   |   [2, 1]   | [2, 1, 1] |
      |  b   |  1   | **3** |   [3, 1]   | [3, 1, 1] |
      |  a   |  1   |   3   | **[3, 4]** | [3, 4, 1] |
      |  g   |  1   |   3   |   [3, 4]   | [3, 4, 5] |
   
3. 完整的dp公式：
   
       1. dp = []int[m+1] [n+1] [n+1]：m为S长度，n为T长度
       2. s[i-1] == t[j-1]：dp[i] [j] [j] = dp[i-1] [j] [j] + dp[i-1] [j-1] [j-1]
       3. s[i-1] != t[j-1]：dp[i] [j] [j] = dp[i-1] [j] [j]

5. 复杂度分析：
   1. 时间复杂度：O(m*n)
   2. 空间复杂度：O(m*$n^2$)

6. Code

   ```go
   /*
   dp：个人写法
   	s[i-1] == t[j-1] {
   		dp[i][j][j] = dp[i-1][j][j] + dp[i-1][j-1][j-1]
   		截止当前字符的个数 + 截止上个字符的个数
   	else
   		dp[i][j][j] = dp[i-1][j][j]
   		当前字符原有的个数
   解释：
   	1.状态定义：行、列、每一个列截止时的子序列
   	2.初始化
   		2.1.初始化dp数组
   		2.2.初始化dp[i][0][0] = 1
   		2.3.拷贝当前行的前一列
   	3.根据dp方程计算值
   		3.1.s[i-1] != t[j-1]
   		3.2.s[i-1] == t[j-1]
   			避免：rab rabb，所以要判断左上角
   */
   func numDistinct(s string, t string) int {
   	m, n := len(s), len(t)
   	dp := make([][][]int, m+1)	// 1
   	for i := 0; i <= m; i++ {	// 2
   		dp[i] = make([][]int, n+1)
   		for j := 0; j <= n; j++ {	// 2.1
   			dp[i][j] = make([]int, n+1)
   		}
   	}
   	dp[0][0][0] = 1	// 2.2
   	for i := 1; i <= m; i++ {	// 3
   		dp[i][0][0] = 1
   		for j := 1; j <= n; j++ {
   			copy(dp[i][j], dp[i][j-1]) // 2.3
   			dp[i][j][j] = dp[i-1][j][j]	// 3.1
   			if s[i-1] == t[j-1] {	// 3.2
   				dp[i][j][j] += dp[i-1][j-1][j-1]
   			}
   		}
   	}
   	return dp[m][n][n]
   }
   ```

8. 优化一：空间O(m*n)，上述写法中，每次 j 出现时，dp第2维和第3维的索引 j 都是同步的

   ```go
   func numDistinct(s string, t string) int {	
   	m, n := len(s), len(t)
   	dp := make([][]int, m+1)
   	dp[0] = make([]int, n+1)
   	dp[0][0] = 1
   	for i := 1; i <= m; i++ {
   		dp[i] = make([]int, n+1)
   		dp[i][0] = 1
   		for j := 1; j <= n; j++ {
   			dp[i][j] = dp[i-1][j]
   			if s[i-1] == t[j-1] {
   				dp[i][j] += dp[i-1][j-1]
   			}
   		}
   	}
   	return dp[m][n]
   }
   ```

8. 优化二：空间O(n)，最精简版

   ```go
   func numDistinct(s string, t string) int {
   	m, n := len(s), len(t)
   	dp := make([]int, n)
   	for i := 0; i < m; i++ {
   		for j, last, pre := 0, 0, 1; j < n; j++ {
   			last, pre = pre, dp[j]
   			if s[i] == t[j] {
   				dp[j] += last
   			}
   		}
   	}
   	return dp[n-1]
   }
   ```

#### 5-最长回文子串

1. 审题过程：根据题意，推进思路

   > 由给出的示例可猜：s = "cbbd"

   1. 暴力法：O($n^3$)第一层循环固定首字符，第二层循环固定尾字符，第三层循环遍历 首尾 之间的子串是否是回文串

      ```go
      for i := 0; i < n; i++ {
          for j := 0; j < n; j++ {
              for l, r := i, j; l < r; l, r = l+1, r-1 {
                  if s[l] != s[r] {
                      // 不是回文子串
                  }
              }
          }
      }
      ```

   2. 根据暴力法，可以发现第二三层循环存在冗余的计算：因为我们已经在第二层循环遍历过 i ~ j 之间的字符了，所以有两种优化的可选思路

      1. 可以想到一种 O($n^2$) 的算法：中心扩展算法（略）
      2. 递推思想：在计算 i ~ j 之间的子串是否为回文串时，可以先看 i+1 ~ j-1 之间的子串是否为回文串

   3. 根据上面的递推思想，可以细化为：

      > 使用二维矩阵，i j 记录子串的起始位置，分三种情况：
      >
      > 1. 当 i==j 时，说明两个指针指向同一个位置，一个字符的子串肯定是回文串
      >
      > 2. s[i] != s[j]，不是回文串
      >
      > 3. s[i] == s[j]，查询已记录的 i+1 ~ j-1 之间的子串是否为回文串，如果是，则 i ~ j 也是
      >
      >    > 可以发现有一种特殊情况：当 i+1==j 时，i+1 ~ j-1 实质又变回了 i ~ j，所以此时不用附加额外的判断

2. 根据推进的同时，画图表支持：由于思路比较简单，且已经很清晰，所以略

   > 注意：通过图表，可以发现该矩阵为对称矩阵，只用遍历一半 + 斜线

3. 状态定义

   1. 由上述分析，我们可以写出状态定义bool矩阵 dp[i] [j]
   2. i：子串起始位置，j：子串终止位置，dp[i] [j]：i ~ j 的子串

4. 状态转移方程

   1. i == j，dp[i] [j] = true

   2. s[i] != s[j]，dp[i] [j] = false

   3. s[i] == s[j]：

      > i+1==j：dp[i] [j] = true
      >
      > 否则：dp[i] [j] = dp[i+1] [j-1]

   4. 记录 max，l 分别表示最长子串，和最长子串的起始位置，根据 dp[i] [j] 的状态，更新 max 和 l 的值

5. 复杂度分析：

   1. 时间复杂度：O($n^2$)
   2. 空间复杂度：O($n^2$)

6. Code

   ```go
   /*
   dp：个人写法
   解释：换个方式，初始化 dp 矩阵记录当前回文串的长度
   	1.边界条件
   	2.记录max，l
   		2.1.更新max，l
   		2.3.根据max，l计算返回值
   	3.递推
   		3.1.i==j
   			dp[i][j] = 1
   		3.2.s[i] != s[j]
   			dp[i][j] = 0
   		3.3.s[i] == s[j] && dp[i+1][j-1] > 0
   			dp[i][j] = dp[i+1][j-1] + 2
   			即 s[i~j] 是回文串
   		3.4.s[i] == s[j] && i+1==j
   			dp[i][j] = 2
   */
   func longestPalindrome(s string) string {
       n := len(s)
   	if n < 2 {	// 1
   		return s
   	}
   	dp, max, l := make([][]int, n), 1, 0	// 2
   	for i := 0; i < n; i++ {	// 3
   		dp[i] = make([]int, n)
   		dp[i][i] = 1	// 3.1
   		for j := 0; j < i; j++ {
   			if s[i] != s[j] {	// 3.2
   				continue
   			}
   			if i-j == 1 {	// 3.4
   				dp[j][i] = 2
   			} else if dp[j+1][i-1] > 0 {	// 3.3
   				dp[j][i] = dp[j+1][i-1] + 2
   			}
   			if dp[j][i] > max {	// 2.1
   				max, l = dp[j][i], j
   			}
   		}
   	}
   	return s[l : l+max]	// 2.2
   }
   ```

